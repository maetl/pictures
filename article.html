<p>It&rsquo;s hard to ignore the utility and convenience of free-for-small-scale-use cloud hosting like <a href="http://code.google.com/appengine/">Google App Engine</a> and <a href="http://heroku.com">Heroku</a> &mdash; these services are ideal for rapid development, making it easy to split common functions of a web application into distributed web services.</p>
<p>
	A good example of where this is handling image uploads. Image uploads are essential in many apps, yet for many years, they have been second class citizens in forms and web frameworks. In Rails, you might end up mucking around with extensions like Paperclip or Attachment Fu; and many CMS tools default to a stupid-simple method of saving directly to a single writable directory on the local filesystem. A popular</p>
<p>
	In this article, we&rsquo;ll look at an alternative way of handling image uploads, using App Engine to build a micro-API for processing image data &ndash; including resizing, thumbnail creation, and indexing via a JSON API. The basic example uses the built-in App Engine data store, but in a production website, it would be better to use just as a generator for resizing and forwarding the images on to a static CDN or dedicated file service such as S3.</p>
<p>
	When I design web services, I often start by sketching out a map of the features that the API needs to support, using the semantics of a service description table:</p>
<h3>Picture Object</h3>
<table>
	<tbody>
		<tr>
			<td>
				<code>GET</code></td>
			<td>
				<code>/picture/{name}.{ext}</code></td>
			<td>
				<code>image/jpeg</code></td>
			<td>
				<p>
					The default size picture, as a JPEG.</p>
			</td>
			<td>
			</td>
		</tr>
		<tr>
			<td>
				<code>POST</code></td>
			<td>
				<code>/picture/{name}.{ext}</code></td>
			<td>
				<code>text/json</code></td>
			<td>
				<p>
					Create a new picture</p>
			</td>
			<td>API key required
			</td>
		</tr>
		<tr>
			<td>
				<code>PUT</code></td>
			<td>
				<code>/picture/{name}.{ext}</code></td>
			<td>
				<code>text/json</code></td>
			<td>
				<p>
					Overwrite an existing picture</p>
			</td>
			<td>API key required
			</td>
		</tr>
		<tr>
			<td>
				<code>DELETE</code></td>
			<td>
				<code>/picture/{name}.{ext}</code></td>
			<td>
				<code>text/json</code></td>
			<td>
				<p>
					Remove an existing picture</p>
			</td>
			<td>API key required
			</td>
		</tr>
	</tbody>
</table>
<p>
	This is the backbone of the API, which enables storage of image objects via a simple method of sending POST and PUT requests to the specific image URL. We can then go further and add some common size variations:</p>
<h3>
	Resized Picture Object</h3>
<table>
	<tbody>
		<tr>
			<td>
				<code>GET</code></td>
			<td>
				<code>/picture/original/{name}.{ext}</code></td>
			<td>
				<code>image/jpeg</code></td>
			<td>
				<p>
					The original uploaded picture.</p>
			</td>
		</tr>
		<tr>
			<td>
				<code>GET</code></td>
			<td>
				<code>/picture/thumb/{name}.{ext}</code></td>
			<td>
				<code>image/jpeg</code></td>
			<td>
				<p>
					Thumbnail version of the picture.</p>
			</td>
		</tr>
	</tbody>
</table>
<p>
	This is where you could do anything you want. For example, Flickr processes images into the following formats:</p>



<p>
	Designers will find this useful when it comes to automating image uploads for a particular grid design &ndash; in that case your CMS API would need to support a set of common proportional image sizes that fit to the particular column widths. You&rsquo;ll then never have to worry about content contributors uploading pictures that break the symmetry of the layout.</p>
<p>
	Now that we have provided the basic structure of a service for storing and accessing any image, we just need to extend the service with metadata to provide clients with a way of scanning an index of the available content, and accessing metadata for each picture:</p>
<table>
	<tbody>
		<tr>
			<td>
				<code>GET</code></td>
			<td>
				<code>/picture/{name}</code></td>
			<td>
				<code>text/json</code></td>
			<td>
				<p>
					Picture metadata</p>
			</td>
		</tr>
		<tr>
			<td>
				<code>GET</code></td>
			<td>
				<code>/pictures</code></td>
			<td>
				<code>text/json</code></td>
			<td>
				<p>
					All pictures in the collection</p>
			</td>
		</tr>
		<tr>
			<td>
				<code>GET</code></td>
			<td>
				<code>/pictures/search?q={query}</code></td>
			<td>
				<code>text/json</code></td>
			<td>
				<p>
					Pictures from search for {query}</p>
			</td>
		</tr>
	</tbody>
</table>
<p>
	Now that we have a map of the service we are building, we can get it running extraordinarily quickly. Create a new app engine project, and configure the app to respond to <code>pictures.py</code>:</p>

<h3>The Model</h3>

<p>
	First, the model to support blob storage in the App Engine data store. We add the blob fields for the different resized formats and some basic metadata for the image &ndash; a caption, and update date.</p>
	
<pre class="code">
class Picture(db.Model):
  name       =  db.StringProperty()
  ext        =  db.StringProperty()
  mime_type  =  db.StringProperty()
  source     =  db.BlobProperty()
  thumb      =  db.BlobProperty()
  default    =  db.BlobProperty()
  caption    =  db.StringProperty()
  updated_at =  db.DateTimeProperty()
</pre>	

<p>
	For convenience, we will encapsulate the processing and storage of the resized blobs in this object, and provide the resource handler with a single method to add an incoming source image, rather than push the handling of multiple size formats into the controller itself. Resizing is handled with calls into the <a href="http://code.google.com/appengine/docs/python/images/imageclass.html#Image_resize">App Engine Image API</a>. If a height value is not provided, the <code>images.resize</code> method calculates this based on the given width and existing aspect ratio.</p>
<pre class="code">
class Picture(db.Model):
  def encode(self, raw_picture, name=False, ext=False):
    self.encode_name(raw_picture, name, ext)

    self.mime_type = raw_picture.type
    self.source = db.Blob(raw_picture.value)

    self.thumb = images.resize(raw_picture.value, 120, 90)
    self.default = images.resize(raw_picture.value, 360)
</pre>

<p>The app also needs to support normalizing name strings for the pictures to be encoded in URL paths. This could be done in a variety of
	ways depending on the design of the URL structures in the app. The encoded name is used to split the file part into a name and
	a file extension, and store them as separate properties on the object. If no name is provided, the filename is guessed
	from the incoming input.</p>
	
<pre class="code">
class Picture(db.Model):
  def encode_name(self, raw_picture, name=False, ext=False):
    if not name:
      basename = os.path.basename(raw_picture.filename)
      filename_part = basename.split('.')
      filename_part.pop()
      name = ''.join(filename_part)
  
    encoded_name = name.lower().replace(' ', '-').replace('_', '-')
    self.name = encoded_name
      
    if not ext:
      ext = raw_picture.type.split('/')[1].replace('jpeg', 'jpg')
  
    self.ext = ext
</pre>

<p>And also convenience method for serializing the object.</p>

<pre class="code">
class Picture(db.Model):	
    def to_obj(self):
        obj = { 'picture': { } }
        obj['picture']['name'] = self.name
        obj['picture']['default'] = '/picture/' + self.filename()
        obj['picture']['thumb'] = '/picture/thumb/' + self.filename()
        obj['picture']['source'] = '/picture/source/' + self.filename()
        obj['picture']['caption'] = self.caption
        obj['picture']['updated_at'] = self.updated_at.isoformat()
        return obj
</pre>

<h3>The Web App</h3>	

	<p>Using the default WSGI Application API, create the following routes to turn this web service sketch into a working prototype:</p>

<pre class="code">
application = webapp.WSGIApplication(
  [
	(&#39;/picture/(.*).jpg&#39;, PictureResource),
	(&#39;/picture/(.*).json&#39;, PictureMeta),
	(&#39;/picture/(original|thumb)/(.*).jpg&#39;, PictureResized)
	(&#39;/pictures&#39;, PicturesCollection),
	(&#39;/pictures/search&#39;, PicturesSearch),
  ], 
  debug=True)
</pre>
<p>This binds to the required handler classes to implement the full URL service map. A stub implementation to respond to HTTP requests on these routes looks like:</p>

<p>To make it easier to implement handlers that respond to HTTP requests, make a base class for handling common JSON responses
	and checking the API key:</p>

<pre class="code">	
class ApiHandler(webapp.RequestHandler):

  def success_response(self, status_code, message, name):
    self.response.set_status(status_code)
    self.response.headers['Content-Type'] = 'text/json'
    simplejson.dump({'success': { 'message': message, 'resource': '/picture/' + name } }, self.response.out)

  def error_response(self, status_code, message):
    self.response.set_status(status_code)
    self.response.headers['Content-Type'] = 'text/json'
    simplejson.dump({'error': { 'status': status_code, 'message': message } }, self.response.out)

  def check_api_key(self):
    return self.request.get('api_key') == API_KEY
</pre>

<h3>Post Requests</h3>

<p>With such a simple API design, there are actually two primary ways of responding to <code>HTTP POST</code> requests, depending on whether the requested URL belongs to the singular or plural URL namespace.</p>

<p>A post to the singular URL <code>/pictures/{name}.{ext}</code> is handled, calling <code>validate_picture_type</code> to ensure that the files mapped respond to the assumed service conventions:</p>

<pre>
class PictureResource(ApiHandler):
	def post(self, name, ext):
	   if not self.
  
	   picture = Picture()
	   picture.encode_name(raw_picture, name, ext)
	   picture.encode_source(raw_picture)
	   picture.caption = self.request.get('caption')
	   picture.save()
  
	   self.success_response(201, 'Picture created', picture.filename())

</pre>

<p>Alternatively, this post hook could be mapped to a plural URL namespace like <code>/pictures</code> or <code>/picture/create</code>. This is less RESTful, but can be very useful for handling form uploads in a CMS by supporting generic posts to a collection:</p>

<pre class="code">
class ApiHandler(webapp.RequestHandler):

</pre>

<p>






